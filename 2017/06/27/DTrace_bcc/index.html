<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>动态追踪技术（四）：基于 Linux bcc/BPF 实现 Go 程序动态追踪 | Ribose Yim&#39;s Home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="摘要 原文：Brendan Gregg’s Blog :《Golang bcc&#x2F;BPF Function Tracing》，31 Jan 2017 引子：gdb、go execution tracer、GODEBUG、gctrace、schedtrace 一、gccgo Function Counting 二、Go gc Function Counting 三、Per-event invocati">
<meta property="og:type" content="article">
<meta property="og:title" content="动态追踪技术（四）：基于 Linux bcc&#x2F;BPF 实现 Go 程序动态追踪">
<meta property="og:url" content="https://riboseyim.com/2017/06/27/DTrace_bcc/index.html">
<meta property="og:site_name" content="Ribose Yim&#39;s Home">
<meta property="og:description" content="摘要 原文：Brendan Gregg’s Blog :《Golang bcc&#x2F;BPF Function Tracing》，31 Jan 2017 引子：gdb、go execution tracer、GODEBUG、gctrace、schedtrace 一、gccgo Function Counting 二、Go gc Function Counting 三、Per-event invocati">
<meta property="og:locale">
<meta property="article:published_time" content="2017-06-27T06:47:15.000Z">
<meta property="article:modified_time" content="2023-08-16T02:50:04.096Z">
<meta property="article:author" content="RiboseYim">
<meta property="article:tag" content="DevOps">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="DTrace">
<meta property="article:tag" content="Golang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Ribose Yim&#39;s Home" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-129742531-2', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


<meta name="generator" content="Hexo 5.4.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://riboseyim.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/tags/DevOps">DevOps</a>
        
          <a class="main-nav-link" href="/tags/Machine-Learning">机器学习</a>
        
          <a class="main-nav-link" href="/tags/Economist">经济学人</a>
        
          <a class="main-nav-link" href="/tags/Policy-Law">Policy&amp;Law</a>
        
          <a class="main-nav-link" href="/charts">图表</a>
        
          <a class="main-nav-link" href="/2017/02/09/eBook">电子书</a>
        
          <a class="main-nav-link" href="/2016/05/31/AboutMe">关于</a>
        
          <a class="main-nav-link" href="https://riboseyim.com">TechBlog</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Ribose Yim&#39;s Home</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-DTrace_bcc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/27/DTrace_bcc/" class="article-date">
  <time datetime="2017-06-27T06:47:15.000Z" itemprop="datePublished">2017-06-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/technology/">工程技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      动态追踪技术（四）：基于 Linux bcc/BPF 实现 Go 程序动态追踪
    </h1>
  

      </header>
      
      <footer class="article-footer">
        <a data-url="https://riboseyim.com/2017/06/27/DTrace_bcc/" data-id="ckwgm33kh004k7b1yfr9k7nug" class="article-share-link">分享</a>
        
        
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DTrace/" rel="tag">DTrace</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DevOps/" rel="tag">DevOps</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

      </footer>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul>
<li>原文：<a target="_blank" rel="noopener" href="http://www.brendangregg.com/blog/2017-01-31/golang-bcc-bpf-function-tracing.html">Brendan Gregg’s Blog :《Golang bcc/BPF Function Tracing》，31 Jan 2017</a></li>
<li>引子：gdb、go execution tracer、GODEBUG、gctrace、schedtrace</li>
<li>一、gccgo Function Counting</li>
<li>二、Go gc Function Counting</li>
<li>三、Per-event invocations of a function</li>
<li>四、Interface Arguments</li>
<li>五、Function Latency</li>
<li>六、总结</li>
<li>七、Tips：构建 LLVM 和 Clang 开发工具库</li>
</ul>
<span id="more"></span>
<p>在这篇文章中，我将迅速调研一种跟踪的 Go 程序的新方法：基于 Linux 4.x eBPF 实现动态跟踪。如果你去搜索 Go 和 BPF，你会发现使用 BPF 接口的 Go 语言接口（例如，gobpf）。这不是我所探索的东西：我将使用 BPF 工具实现 Go 应用程序的性能分析和调试。</p>
<p>目前已经有多种调试和追踪 Go 程序的方法，包括但不限于：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://golang.org/doc/gdb">gdb</a></li>
<li><p><a target="_blank" rel="noopener" href="https://golang.org/pkg/runtime/trace/">go execution tracer</a> ：用于高层异常和阻塞事件</p>
<blockquote>
<p>Go execution tracer. (import “runtime/trace”)<br>The tracer captures a wide range of execution events like goroutine creation/blocking/unblocking, syscall enter/exit/block, GC-related events, changes of heap size, processor start/stop, etc and writes them to an io.Writer in a compact form. A precise nanosecond-precision timestamp and a stack trace is captured for most events. A trace can be analyzed later with ‘go tool trace’ command.</p>
</blockquote>
</li>
<li><p><strong>GODEBUG</strong> （一个跨平台的Go程序调试工具）、 <strong>gctrace</strong> 和 <strong>schedtrace</strong></p>
</li>
</ul>
<p>BPF 追踪以做很多事，但都有自己的优点和缺点，接下来将详细说明。首先我从一个简单的 Go 程序开始（ hello.go）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello, BPF!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一、gccgo-Function-Counting"><a href="#一、gccgo-Function-Counting" class="headerlink" title="一、gccgo Function Counting"></a>一、gccgo Function Counting</h2><p>我开始会使用 gccgo 编译，然后使用 Go gc 编译器 。（区别：gccgo 可以生成优化后的二进制文件，但是基于老版本的 Go。）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 编译</span></span><br><span class="line">$ gccgo -o hello hello.go</span><br><span class="line">$ ./hello</span><br><span class="line">Hello, BPF!</span><br></pre></td></tr></table></figure>
<p>现在我将使用 <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc">bcc</a> 工具的 <strong>funccount</strong> 来动态跟踪和计数所有以 “fmt.” 开头的 Go 库函数调用，在另一个终端重新运行 Hello 程序效果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># funccount &#x27;go:fmt.*&#x27;</span></span><br><span class="line">Tracing 160 <span class="built_in">functions</span> <span class="keyword">for</span> <span class="string">&quot;go:fmt.*&quot;</span>... Hit Ctrl-C to end.</span><br><span class="line">^C</span><br><span class="line">FUNC                                    COUNT</span><br><span class="line">fmt..import                                 1</span><br><span class="line">fmt.padString.pN7_fmt.fmt                   1</span><br><span class="line">fmt.fmt_s.pN7_fmt.fmt                       1</span><br><span class="line">fmt.WriteString.pN10_fmt.buffer             1</span><br><span class="line">fmt.free.pN6_fmt.pp                         1</span><br><span class="line">fmt.fmtString.pN6_fmt.pp                    1</span><br><span class="line">fmt.doPrint.pN6_fmt.pp                      1</span><br><span class="line">fmt.init.pN7_fmt.fmt                        1</span><br><span class="line">fmt.printArg.pN6_fmt.pp                     1</span><br><span class="line">fmt.WriteByte.pN10_fmt.buffer               1</span><br><span class="line">fmt.Println                                 1</span><br><span class="line">fmt.truncate.pN7_fmt.fmt                    1</span><br><span class="line">fmt.Fprintln                                1</span><br><span class="line">fmt.<span class="variable">$nested1</span>                                1</span><br><span class="line">fmt.newPrinter                              1</span><br><span class="line">fmt.clearflags.pN7_fmt.fmt                  2</span><br><span class="line">Detaching...</span><br></pre></td></tr></table></figure>
<p>Neat! 输出结果中包含该程序的 <strong>fmt.Println()</strong> 函数调用。</p>
<p>我不需要进入任何特殊的模式才能实现这个效果，对于一个已经在运行的 Go 应用我可以直接开始测量而不需要重启进程。 <strong>So how does it even work?</strong> 这要归功于 <strong>uprobes</strong> ，Linux 3.5 新增的特性，详见<a target="_blank" rel="noopener" href="http://www.brendangregg.com/blog/2015-06-28/linux-ftrace-uprobe.html">Linux uprobes: User-Level Dynamic Tracing</a> 。</p>
<blockquote>
<p>It overwrites instructions with a soft interrupt to kernel instrumentation, and reverses the process when tracing has ended.</p>
</blockquote>
<p>gccgo 编译的输出提供一个标准的符号表用于函数查找。在这种情况下，我利用 libgo 当测量工具（假定“lib”在“go:”之前），作为 gccgo 发出的一个二进制动态链接库（libgo 包含 fmt 包）。uprobes 可以连接到已经运行的进程，或者像我现在一样作为一个二进制库，捕捉所有调用自己的进程。</p>
<p>为了提高效率，我在内核上下文中进行函数调用计数，只将计数发送到用户空间。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ file hello</span><br><span class="line">hello: ELF <span class="number">64</span>-bit LSB executable, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>, <span class="keyword">for</span> GNU/Linux <span class="number">2.6</span><span class="number">.32</span>, BuildID[sha1]=<span class="number">4</span>dc45f1eb023f44ddb32c15bbe0fb4f933e61815, not stripped</span><br><span class="line">$ ls -lh hello</span><br><span class="line">-rwxr-xr-x <span class="number">1</span> bgregg root <span class="number">29</span>K Jan <span class="number">12</span> <span class="number">21</span>:<span class="number">18</span> hello</span><br><span class="line">$ ldd hello</span><br><span class="line">    linux-vdso.so<span class="number">.1</span> =&gt;  (<span class="number">0x00007ffc4cb1a000</span>)</span><br><span class="line">    libgo.so<span class="number">.9</span> =&gt; /usr/lib/x86_64-linux-gnu/libgo.so<span class="number">.9</span> (<span class="number">0x00007f25f2407000</span>)</span><br><span class="line">    libgcc_s.so<span class="number">.1</span> =&gt; /lib/x86_64-linux-gnu/libgcc_s.so<span class="number">.1</span> (<span class="number">0x00007f25f21f1000</span>)</span><br><span class="line">    libc.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libc.so<span class="number">.6</span> (<span class="number">0x00007f25f1e27000</span>)</span><br><span class="line">    /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x0000560b44960000</span>)</span><br><span class="line">    libpthread.so<span class="number">.0</span> =&gt; /lib/x86_64-linux-gnu/libpthread.so<span class="number">.0</span> (<span class="number">0x00007f25f1c0a000</span>)</span><br><span class="line">    libm.so<span class="number">.6</span> =&gt; /lib/x86_64-linux-gnu/libm.so<span class="number">.6</span> (<span class="number">0x00007f25f1901000</span>)</span><br><span class="line">$ objdump -tT /usr/lib/x86_64-linux-gnu/libgo.so<span class="number">.9</span> | grep fmt.Println</span><br><span class="line"><span class="number">0000000001221070</span> g     O .data.rel.ro   <span class="number">0000000000000008</span>              fmt.Println$descriptor</span><br><span class="line"><span class="number">0000000000978090</span> g     F .text  <span class="number">0000000000000075</span>              fmt.Println</span><br><span class="line"><span class="number">0000000001221070</span> g    DO .data.rel.ro   <span class="number">0000000000000008</span>  Base        fmt.Println$descriptor</span><br><span class="line"><span class="number">0000000000978090</span> g    DF .text  <span class="number">0000000000000075</span>  Base        fmt.Println</span><br></pre></td></tr></table></figure>
<p>这些内容看起来非常像一个编译过的 C 语言二进制程序，因此可以使用包括 bcc/BPF在内的许多现有的调试工具和追踪器观测。相对于测量即时编译的运行时要简单得多（例如 Java 和 Node.js）。到目前为止，这个例子唯一的麻烦事函数名称中可能包含非标准的字符，例如“.”。</p>
<p><strong>funccount</strong> also has options like -p to match a PID, and -i to emit output every interval. It currently can only handle up to 1000 probes at a time, so “fmt.*“ was ok, but matching everything in libgo:</p>
<p><strong>funccount</strong> 提供 -p 选项来匹配进程号（PID），-i 选项来控制输出频率。它目前能够同时处理 1000 个探测点，匹配 “fmt.*” 时运行正常，但是匹配 libgo 的所有函数就出现异常。诸如此类的问题在 bcc/BPF 中还有不少，我们需要寻找其它的方法来处理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># funccount &#x27;go:*&#x27;</span></span><br><span class="line">maximum of 1000 probes allowed, attempted 21178</span><br></pre></td></tr></table></figure>
<h2 id="二、Go-gc-Function-Counting"><a href="#二、Go-gc-Function-Counting" class="headerlink" title="二、Go gc Function Counting"></a>二、Go gc Function Counting</h2><p>使用 Go 语言的 gc 编译器实现 fmt 函数调用计数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go build hello.go</span><br><span class="line">$ ./hello</span><br><span class="line">Hello, BPF!</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># funccount &#x27;/home/bgregg/hello:fmt.*&#x27;</span></span><br><span class="line">Tracing 78 <span class="built_in">functions</span> <span class="keyword">for</span> <span class="string">&quot;/home/bgregg/hello:fmt.*&quot;</span>... Hit Ctrl-C to end.</span><br><span class="line">^C</span><br><span class="line">FUNC                                    COUNT</span><br><span class="line">fmt.init.1                                  1</span><br><span class="line">fmt.(*fmt).padString                        1</span><br><span class="line">fmt.(*fmt).truncate                         1</span><br><span class="line">fmt.(*fmt).fmt_s                            1</span><br><span class="line">fmt.newPrinter                              1</span><br><span class="line">fmt.(*pp).free                              1</span><br><span class="line">fmt.Fprintln                                1</span><br><span class="line">fmt.Println                                 1</span><br><span class="line">fmt.(*pp).fmtString                         1</span><br><span class="line">fmt.(*pp).printArg                          1</span><br><span class="line">fmt.(*pp).doPrint                           1</span><br><span class="line">fmt.glob.func1                              1</span><br><span class="line">fmt.init                                    1</span><br><span class="line">Detaching...</span><br></pre></td></tr></table></figure>
<p>你依然能够追踪到 fmt.Println() ，这个二进制程序与 libgo 有所不同：包含该函数的是一个 2M 的静态库（而非动态库的 29K ）。另一个区别就是函数名称包含更多特殊字符，例如 “*“, “(“,等等，我怀疑如果不能修正处理的haul将影响其它调试器（例如 bcc 追踪器）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ file hello</span><br><span class="line">hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped</span><br><span class="line">$ ls -lh hello</span><br><span class="line">-rwxr-xr-x 1 bgregg root 2.2M Jan 12 05:16 hello</span><br><span class="line">$ ldd hello</span><br><span class="line">    not a dynamic executable</span><br><span class="line">$ objdump -t hello | grep fmt.Println</span><br><span class="line">000000000045a680 g     F .text  00000000000000e0 fmt.Println</span><br></pre></td></tr></table></figure>
<h2 id="三、Per-event-invocations-of-a-function"><a href="#三、Per-event-invocations-of-a-function" class="headerlink" title="三、Per-event invocations of a function"></a>三、Per-event invocations of a function</h2><h4 id="3-1-gccgo-Function-Tracing"><a href="#3-1-gccgo-Function-Tracing" class="headerlink" title="3.1 gccgo Function Tracing"></a>3.1 gccgo Function Tracing</h4><p>现在我将尝试使用 <a target="_blank" rel="noopener" href="https://www.linkedin.com/in/sashag/?ppe=1">Sasha Goldshtein</a> 的追踪工具，也是基于 <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc">bcc</a>，用来查看每一个函数调用事件。我将回到 gccgo，使用一个非常简单的示例程序（ from the <a target="_blank" rel="noopener" href="https://tour.golang.org/basics/4">go tour</a> ），functions.go:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(add(<span class="number">42</span>, <span class="number">13</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>追踪 add() 函数。所有参数都输出在右侧，trace 还有其他选项（帮助 -h ），例如输出时间戳和堆栈。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\<span class="comment"># trace &#x27;/home/bgregg/functions:main.add&#x27;</span></span><br><span class="line">PID    TID    COMM         FUNC             </span><br><span class="line">14424  14424  <span class="built_in">functions</span>    main.add  </span><br><span class="line"></span><br><span class="line"><span class="comment">#... and with both its arguments:</span></span><br><span class="line"></span><br><span class="line">\<span class="comment"># trace &#x27;/home/bgregg/functions:main.add &quot;%d %d&quot; arg1, arg2&#x27;</span></span><br><span class="line">PID    TID    COMM         FUNC             -</span><br><span class="line">14390  14390  <span class="built_in">functions</span>    main.add         42 13</span><br></pre></td></tr></table></figure>
<h4 id="3-2-Go-gc-Function-Tracing"><a href="#3-2-Go-gc-Function-Tracing" class="headerlink" title="3.2 Go gc Function Tracing"></a>3.2 Go gc Function Tracing</h4><p>同样的程序，如果使用 go build 就没有 main.add() ?  禁用代码嵌入（ Disabling inlining）即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build functions.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"># trace <span class="string">&#x27;/home/bgregg/functions:main.add &quot;%d %d&quot; arg1, arg2&#x27;</span></span><br><span class="line">could not determine address of symbol main.add</span><br><span class="line"></span><br><span class="line">$ objdump -t functions | grep main.add</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build -gcflags <span class="string">&#x27;-l&#x27;</span> functions.<span class="keyword">go</span></span><br><span class="line">$ objdump -t functions | grep main.add</span><br><span class="line"><span class="number">0000000000401000</span> g     F .text  <span class="number">0000000000000020</span> main.add</span><br><span class="line"></span><br><span class="line"># trace <span class="string">&#x27;/home/bgregg/functions:main.add &quot;%d %d&quot; arg1, arg2&#x27;</span></span><br><span class="line">PID    TID    COMM         FUNC             -</span><br><span class="line"><span class="number">16061</span>  <span class="number">16061</span>  functions    main.add         <span class="number">536912504</span> <span class="number">16</span></span><br></pre></td></tr></table></figure>
<p><strong>That’s wrong.</strong> 参数应该是 42 和 13 而不是 536912504 和 16。<br>使用 gdb 查看结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">$ gdb ./<span class="built_in">functions</span></span><br><span class="line">[...]</span><br><span class="line">warning: File <span class="string">&quot;/usr/share/go-1.6/src/runtime/runtime-gdb.py&quot;</span> auto-loading has been declined</span><br><span class="line"> by your <span class="string">&#x27;auto-load safe-path&#x27;</span> <span class="built_in">set</span> to <span class="string">&quot;<span class="variable">$debugdir</span>:<span class="variable">$datadir</span>/auto-load&quot;</span>.</span><br><span class="line">[...]</span><br><span class="line">(gdb) b main.add</span><br><span class="line">Breakpoint 1 at 0x401000: file /home/bgregg/functions.go, line 6.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/bgregg/<span class="built_in">functions</span></span><br><span class="line">[New LWP 16082]</span><br><span class="line">[New LWP 16083]</span><br><span class="line">[New LWP 16084]</span><br><span class="line">Thread 1 <span class="string">&quot;functions&quot;</span> hit Breakpoint 1, main.add (x=42, y=13, ~r2=4300314240) at</span><br><span class="line"> /home/bgregg/functions.go:6</span><br><span class="line">6           <span class="built_in">return</span> x + y</span><br><span class="line">(gdb) i r</span><br><span class="line">rax            0xc820000180 859530330496</span><br><span class="line">rbx            0x584ea0 5787296</span><br><span class="line">rcx            0xc820000180 859530330496</span><br><span class="line">rdx            0xc82005a048 859530698824</span><br><span class="line">rsi            0x10 16</span><br><span class="line">rdi            0xc82000a2a0 859530371744</span><br><span class="line">rbp            0x0  0x0</span><br><span class="line">rsp            0xc82003fed0 0xc82003fed0</span><br><span class="line">r8             0x41 65</span><br><span class="line">r9             0x41 65</span><br><span class="line">r10            0x4d8ba0 5082016</span><br><span class="line">r11            0x0  0</span><br><span class="line">r12            0x10 16</span><br><span class="line">r13            0x52a3c4 5415876</span><br><span class="line">r14            0xa  10</span><br><span class="line">r15            0x8  8</span><br><span class="line">rip            0x401000 0x401000</span><br><span class="line">eflags         0x206    [ PF IF ]</span><br><span class="line">cs             0xe033   57395</span><br><span class="line">ss             0xe02b   57387</span><br><span class="line">ds             0x0  0</span><br><span class="line">es             0x0  0</span><br><span class="line">fs             0x0  0</span><br><span class="line">gs             0x0  0</span><br></pre></td></tr></table></figure>
<p>启动信息中包含一个关于 runtime-gdb.py 的警告，它非常有用：如果需要进一步深入挖掘 Go 上下文，我希望能够修复并找出告警原因。即使没有该信息，gdb 依然可以输出参数变量的值是 “x=42, y=13”。我也将它们从寄存器导出与 x86_64 ABI（Application Binary Interface，应用程序二进制接口）对比，which is how bcc’s trace reads them. From the syscall(2) man page:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">       arch/ABI      arg1  arg2  arg3  arg4  arg5  arg6  arg7  Notes</span><br><span class="line">       ──────────────────────────────────────────────────────────────────</span><br><span class="line">[...]</span><br><span class="line">       x86_64        rdi   rsi   rdx   r10   r8    r9    -</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The reason is that Go’s gc compiler is not following the standard AMD64 ABI function calling convention, which causes problems with this and other debuggers.</p>
</blockquote>
<p>42 和 13 没有出现在 rdi , rsi 或者其它任何一个寄存器。原因是 Go 的 gc 编译器不遵循标准的 AMD64 ABI 函数调用约定，其它调试器也会存在这个问题。这很烦人。我猜 Go 语言的返回值使用的是另外一种 ABI，因为它可以返回多个值，所以即使入口参数是标准的，我们仍然会遇到差异。我浏览了指南（Quick Guide to Go’s Assembler and the Plan 9 assembly manual），看起来函数在堆栈上传递。这些是我们的 42 和 13：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/<span class="number">3</span>dg $rsp</span><br><span class="line"><span class="number">0xc82003fed0</span>:   <span class="number">4198477</span> <span class="number">42</span></span><br><span class="line"><span class="number">0xc82003fee0</span>:   <span class="number">13</span></span><br></pre></td></tr></table></figure>
<p>BPF can dig these out too. As a proof of concept, I just hacked in a couple of new aliases, “go1” and “go2” for those entry arguments:</p>
<p>BPF 也可以挖掘这些信息。为了验证这一个概念，我为入口参数声明一对新的别名“go1”和“go2” 。希望您阅读本文的时候，我（或者其他人）已经将它加入到 bcc 追踪工具中，最好是 “goarg1”, “goarg2”, 等等。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># trace &#x27;/home/bgregg/functions:main.add &quot;%d %d&quot; go1, go2&#x27;</span></span><br><span class="line">PID    TID    COMM         FUNC             -</span><br><span class="line">17555  17555  <span class="built_in">functions</span>    main.add         42 13</span><br></pre></td></tr></table></figure>
<h2 id="四、Interface-Arguments"><a href="#四、Interface-Arguments" class="headerlink" title="四、Interface Arguments"></a>四、Interface Arguments</h2><p>你可以写一个自定义的 bcc/BPF 程序来挖掘，为了处理接口参数我们可以给 bcc 的跟踪程序添加多个别名。输入参数是接口的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Fprintln(os.Stdout, a...)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ gdb ./hello</span><br><span class="line">[...]</span><br><span class="line">(gdb) b fmt.Println</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x401c50</span></span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/bgregg/hello</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line">[New Thread <span class="number">0x7ffff449c700</span> (LWP <span class="number">16836</span>)]</span><br><span class="line">[New Thread <span class="number">0x7ffff3098700</span> (LWP <span class="number">16837</span>)]</span><br><span class="line">[Switching to Thread <span class="number">0x7ffff3098700</span> (LWP <span class="number">16837</span>)]</span><br><span class="line">Thread <span class="number">3</span> <span class="string">&quot;hello&quot;</span> hit Breakpoint <span class="number">1</span>, fmt.Println (a=...) at ../../../src/libgo/<span class="keyword">go</span>/fmt/<span class="built_in">print</span>.<span class="keyword">go</span>:<span class="number">263</span></span><br><span class="line"><span class="number">263</span> ../../../src/libgo/<span class="keyword">go</span>/fmt/<span class="built_in">print</span>.<span class="keyword">go</span>: No such file or directory.</span><br><span class="line">(gdb) p a</span><br><span class="line">$<span class="number">1</span> = &#123;__values = <span class="number">0xc208000240</span>, __count = <span class="number">1</span>, __capacity = <span class="number">1</span>&#125;</span><br><span class="line">(gdb) p a.__values</span><br><span class="line">$<span class="number">18</span> = (<span class="keyword">struct</span> &#123;...&#125; *) <span class="number">0xc208000240</span></span><br><span class="line">(gdb) p a.__values[<span class="number">0</span>]</span><br><span class="line">$<span class="number">20</span> = &#123;__type_descriptor = <span class="number">0x4037c0</span> &lt;__go_tdn_string&gt;, __object = <span class="number">0xc208000210</span>&#125;</span><br><span class="line">(gdb) x/s *<span class="number">0xc208000210</span></span><br><span class="line"><span class="number">0x403483</span>:   <span class="string">&quot;Hello, BPF!&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="五、Function-Latency"><a href="#五、Function-Latency" class="headerlink" title="五、Function Latency"></a>五、Function Latency</h2><ul>
<li>示例：循环调用 fmt.Println() 函数的时延直方图（纳秒）</li>
</ul>
<p><strong>WARNING:</strong> Go 函数调用过程中，如果从一个进程（goroutine）切换到另外一个系统进程，<strong>funclatency</strong> 无法匹配入口-返回。这种场景需要一个新的工具 —— <strong>gofunclatency</strong> ，它基于 Go 内建的 GOID 替代系统的 TID 追踪时延，在某些情况下， <strong>uretprobes</strong> 修改 Go 程序可能出现崩溃的问题，因此在调试之前需要准备周全的计划。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># funclatency <span class="string">&#x27;go:fmt.Println&#x27;</span></span><br><span class="line">Tracing <span class="number">1</span> functions <span class="keyword">for</span> <span class="string">&quot;go:fmt.Println&quot;</span>... Hit Ctrl-C to end.</span><br><span class="line"></span><br><span class="line">Function = fmt.Println [<span class="number">3041</span>]</span><br><span class="line">     nsecs               : count     distribution</span><br><span class="line">         <span class="number">0</span> -&gt; <span class="number">1</span>          : <span class="number">0</span>        |                                        |</span><br><span class="line">         <span class="number">2</span> -&gt; <span class="number">3</span>          : <span class="number">0</span>        |                                        |</span><br><span class="line">         <span class="number">4</span> -&gt; <span class="number">7</span>          : <span class="number">0</span>        |                                        |</span><br><span class="line">         <span class="number">8</span> -&gt; <span class="number">15</span>         : <span class="number">0</span>        |                                        |</span><br><span class="line">        <span class="number">16</span> -&gt; <span class="number">31</span>         : <span class="number">0</span>        |                                        |</span><br><span class="line">        <span class="number">32</span> -&gt; <span class="number">63</span>         : <span class="number">0</span>        |                                        |</span><br><span class="line">        <span class="number">64</span> -&gt; <span class="number">127</span>        : <span class="number">0</span>        |                                        |</span><br><span class="line">       <span class="number">128</span> -&gt; <span class="number">255</span>        : <span class="number">0</span>        |                                        |</span><br><span class="line">       <span class="number">256</span> -&gt; <span class="number">511</span>        : <span class="number">0</span>        |                                        |</span><br><span class="line">       <span class="number">512</span> -&gt; <span class="number">1023</span>       : <span class="number">0</span>        |                                        |</span><br><span class="line">      <span class="number">1024</span> -&gt; <span class="number">2047</span>       : <span class="number">0</span>        |                                        |</span><br><span class="line">      <span class="number">2048</span> -&gt; <span class="number">4095</span>       : <span class="number">0</span>        |                                        |</span><br><span class="line">      <span class="number">4096</span> -&gt; <span class="number">8191</span>       : <span class="number">0</span>        |                                        |</span><br><span class="line">      <span class="number">8192</span> -&gt; <span class="number">16383</span>      : <span class="number">27</span>       |****************************************|</span><br><span class="line">     <span class="number">16384</span> -&gt; <span class="number">32767</span>      : <span class="number">3</span>        |****                                    |</span><br><span class="line">Detaching...</span><br></pre></td></tr></table></figure>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>原作者总结很简洁，不再赘述。</p>
<blockquote>
<p>I took a quick look at Golang with dynamic tracing and Linux enhanced BPF, via bcc’s funccount and trace tools, with some successes and some challenges. Counting function calls works already. Tracing function arguments when compiled with gccgo also works, whereas Go’s gc compiler doesn’t follow the standard ABI calling convention, so the tools need to be updated to support this. As a proof of concept I modified the bcc trace tool to show it could be done, but that feature needs to be coded properly and integrated. Processing interface objects will also be a challenge, and multi-return values, again, areas where we can improve the tools to make this easier, as well as add macros to C for writing other custom Go observability tools as well.</p>
</blockquote>
<h2 id="七、Tips"><a href="#七、Tips" class="headerlink" title="七、Tips"></a>七、Tips</h2><h4 id="6-1-安装和编译-BCC"><a href="#6-1-安装和编译-BCC" class="headerlink" title="6.1 安装和编译 BCC"></a>6.1 安装和编译 BCC</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iovisor/bcc.git</span><br><span class="line">mkdir bcc/build; cd bcc/build</span><br><span class="line">cmake -DCMAKE_INSTALL_PREFIX=/usr \</span><br><span class="line">      -DLUAJIT_INCLUDE_DIR=`pkg-config --variable=includedir luajit` \ # for lua support</span><br><span class="line">      ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">cmake -DPYTHON_CMD=python3 .. # build python3 binding</span><br><span class="line">pushd src/python/</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">popd</span><br></pre></td></tr></table></figure>
<h4 id="6-2-构建-LLVM-和-Clang-开发工具库"><a href="#6-2-构建-LLVM-和-Clang-开发工具库" class="headerlink" title="6.2 构建 LLVM 和 Clang 开发工具库"></a>6.2 构建 LLVM 和 Clang 开发工具库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc</span><br><span class="line">yum install gcc-g++</span><br><span class="line"></span><br><span class="line">wget https://cmake.org/files/v3.9/cmake-3.9.0-rc4.tar.gz</span><br><span class="line">tar -xvf cmake-3.9.0-rc4.tar.gz</span><br><span class="line"><span class="built_in">cd</span> cmake-3.9.0</span><br><span class="line">./bootstrap  </span><br><span class="line">gmake</span><br><span class="line">gmake install</span><br><span class="line"><span class="built_in">export</span> CMAKE_ROOT=/usr/<span class="built_in">local</span>/share/cmake-3.9.0</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$CMAKE_ROOT</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> http://llvm.org/git/llvm.git</span><br><span class="line"><span class="built_in">cd</span> llvm/tools;</span><br><span class="line">git <span class="built_in">clone</span> http://llvm.org/git/clang.git</span><br><span class="line"><span class="built_in">cd</span> ..; mkdir -p build/install; <span class="built_in">cd</span> build</span><br><span class="line">cmake -G \&quot;Unix Makefiles\&quot; -DLLVM_TARGETS_TO_BUILD=\&quot;BPF;X86\&quot; -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=<span class="variable">$PWD</span>/install ..</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PWD</span>/install/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<h4 id="6-3-LLVM-与-Clang"><a href="#6-3-LLVM-与-Clang" class="headerlink" title="6.3 LLVM 与 Clang"></a>6.3 LLVM 与 Clang</h4><p>LLVM （Low Level Virtual Machine）是一种编译器基础设施，以C++写成。起源于2000年伊利诺伊大学厄巴纳-香槟分校维克拉姆·艾夫（Vikram Adve）与克里斯·拉特纳（Chris Lattner）的研究，他们想要为所有静态及动态语言创造出动态的编译技术。2005年，Apple直接雇用了克里斯·拉特纳及他的团队，为了苹果电脑开发应用程序，期间克里斯·拉特纳设计发明了 Swift 语言，LLVM 成为 Mac OS X 及 iOS 开发工具的一部分。LLVM 的范围早已经不局限于创建一个虚拟机，成为了众多编译工具及低级工具技术的统称，适用于LLVM下的所有项目，包含LLVM中介码（LLVM IR）、LLVM除错工具、LLVM C++标准库等。</p>
<p>目前 LLVM 已支持包括ActionScript、Ada、D语言、Fortran、GLSL、Haskell、Java字节码、Objective-C、Swift、Python、Ruby、Rust、Scala1以及C#等语言。</p>
<p>Clang 是LLVM编译器工具集的前端（front-end），目的是输出代码对应的抽象语法树（Abstract Syntax Tree, AST），并将代码编译成LLVM Bitcode。接着在后端（back-end）使用 LLVM 编译成平台相关的机器语言 。Clang支持C、C++、Objective C。它的目标是提供一个 GCC 的替代品。作者是克里斯·拉特纳（Chris Lattner），在苹果公司的赞助支持下进行开发。Clang项目包括Clang前端和Clang静态分析器等。</p>
<h4 id="6-4-ABI"><a href="#6-4-ABI" class="headerlink" title="6.4 ABI"></a>6.4 ABI</h4><p>应用二进制接口（Application Binary Interface， ABI）描述了应用程序和操作系统之间或其他应用程序的低级接口。ABI涵盖了各种细节，如：</p>
<ul>
<li>数据类型的大小、布局;</li>
<li>调用约定（控制着函数的参数如何传送以及如何接受返回值），例如，是所有的参数都通过栈传递，还是部分参数通过寄存器传递；哪个寄存器用于哪个函数参数；通过栈传递的第一个函数参数是最先push到栈上还是最后；</li>
<li><p>目标文件的二进制格式、程序库等等。</p>
</li>
<li><p>ABI vs API<br>应用程序接口 (API)定义了源代码和库之间的接口，因此同样的代码可以在支持这个API的任何系统中编译，然而ABI允许编译好的目标代码在使用兼容 ABI 的系统中无需改动就能运行。</p>
</li>
</ul>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h4 id="动态追踪技术"><a href="#动态追踪技术" class="headerlink" title="动态追踪技术"></a>动态追踪技术</h4><ul>
<li><a target="_blank" rel="noopener" href="https://riboseyim.github.io/2017/05/29/Linux-Works/">操作系统原理 | How Linux Works（一）：How the Linux Kernel Boots</a></li>
<li><a target="_blank" rel="noopener" href="https://riboseyim.github.io/2017/05/29/Linux-Works/">操作系统原理 | How Linux Works（二）：User Space &amp; RAM</a></li>
<li><a target="_blank" rel="noopener" href="https://riboseyim.github.io/2017/12/11/Linux-Works-Memory/">操作系统原理 | How Linux Works（三）：Memory</a></li>
<li><a target="_blank" rel="noopener" href="https://riboseyim.github.io/2016/11/26/DTrace/">动态追踪技术(一)：DTrace 导论</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5MTY1MjQ3Nw==&amp;mid=2651939588&amp;idx=1&amp;sn=35f71c5f88d1edf23cb2efc812ab8e6c&amp;chksm=bd578c168a20050041c08618281691f0111f61c789097a69095933057618637fc54817815921#rd">动态追踪技术(二)：strace+gdb 溯源 Nginx 内存溢出异常 </a></li>
<li><a target="_blank" rel="noopener" href="https://riboseyim.github.io/2017/04/17/DTrace_FTrace/">动态追踪技术(三)：Tracing Your Kernel Function!</a></li>
<li><a target="_blank" rel="noopener" href="https://riboseyim.github.io/2017/06/27/DTrace_bcc/">动态追踪技术(四)：基于 Linux bcc/BPF 实现 Go 程序动态追踪</a></li>
<li><a target="_blank" rel="noopener" href="https://riboseyim.github.io/2018/02/16/DTrace-Linux/">动态追踪技术(五)：Welcome DTrace for Linux</a></li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.brendangregg.com/blog/2016-10-04/linux-bcc-mysqld-qslower.html">Linux MySQL Slow Query Tracing with bcc/BPF | Brendan Gregg’s Blog</a></li>
<li><a target="_blank" rel="noopener" href="https://jvns.ca/blog/2017/06/28/notes-on-bpf---ebpf/">Notes on BPF &amp; eBPF | Julia Evans</a></li>
<li><a target="_blank" rel="noopener" href="http://blogs.microsoft.co.il/sasha/2016/03/31/probing-the-jvm-with-bpfbcc/">Probing the JVM with BPF/BCC | Sasha</a></li>
<li><a target="_blank" rel="noopener" href="https://www.slideshare.net/brendangregg/bpf-tracing-and-more">BPF: Tracing and more | Brendan Gregg SlideShare </a></li>
<li><a target="_blank" rel="noopener" href="http://morsmachine.dk/http2-causalprof">Using Causal Profiling to Optimize the Go HTTP/2 Server</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://riboseyim.com/2017/06/27/DTrace_bcc/" data-id="ckwgm33kh004k7b1yfr9k7nug" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DTrace/" rel="tag">DTrace</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DevOps/" rel="tag">DevOps</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>

  
    <div class="article-entry" itemprop="articleBody">
      <p>
      欢迎扫码关注微信公众号获取最新动态，读者交流 QQ 群：338272982 。
      <br>
      </p>
      <p>
        <a href="https://riboseyim.com" title="微信公众号@睿哥杂货铺" rel="fancy-group" class="fancy-ctn fancybox">
          <img src="http://riboseyim-qiniu.riboseyim.com/ID_RiboseYim_201812.png" title="微信公众号@睿哥杂货铺">
        </a>
      </p>
    </div>
    
 
<script src="/jquery/jquery.min.js"></script>

  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =10
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2017/06/27/TeamWork-Knowledge-Sharing/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          The Road To Leader：构建知识共享型团队
        
      </div>
    </a>
  
  
    <a href="/2017/06/27/Technology-English/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">工程师的自我修养：全英文技术学习实践</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
       
      
      
  </div>
 
  
</section>
           
    <aside id="sidebar">
  
    

  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%91%98%E8%A6%81"><span class="toc-number">1.</span> <span class="toc-text">摘要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81gccgo-Function-Counting"><span class="toc-number">2.</span> <span class="toc-text">一、gccgo Function Counting</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Go-gc-Function-Counting"><span class="toc-number">3.</span> <span class="toc-text">二、Go gc Function Counting</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Per-event-invocations-of-a-function"><span class="toc-number">4.</span> <span class="toc-text">三、Per-event invocations of a function</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-gccgo-Function-Tracing"><span class="toc-number">4.0.1.</span> <span class="toc-text">3.1 gccgo Function Tracing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-Go-gc-Function-Tracing"><span class="toc-number">4.0.2.</span> <span class="toc-text">3.2 Go gc Function Tracing</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Interface-Arguments"><span class="toc-number">5.</span> <span class="toc-text">四、Interface Arguments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Function-Latency"><span class="toc-number">6.</span> <span class="toc-text">五、Function Latency</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">六、总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81Tips"><span class="toc-number">8.</span> <span class="toc-text">七、Tips</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E5%AE%89%E8%A3%85%E5%92%8C%E7%BC%96%E8%AF%91-BCC"><span class="toc-number">8.0.1.</span> <span class="toc-text">6.1 安装和编译 BCC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E6%9E%84%E5%BB%BA-LLVM-%E5%92%8C-Clang-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%BA%93"><span class="toc-number">8.0.2.</span> <span class="toc-text">6.2 构建 LLVM 和 Clang 开发工具库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-LLVM-%E4%B8%8E-Clang"><span class="toc-number">8.0.3.</span> <span class="toc-text">6.3 LLVM 与 Clang</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-ABI"><span class="toc-number">8.0.4.</span> <span class="toc-text">6.4 ABI</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB"><span class="toc-number">9.</span> <span class="toc-text">扩展阅读</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AF"><span class="toc-number">9.0.1.</span> <span class="toc-text">动态追踪技术</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-number">10.</span> <span class="toc-text">参考文献</span></a></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
      <div  style="width:100%;margin:0 auto; padding:10px 0;text-align:center">
      &copy; 2008 - 2023 RiboseYim&nbsp;
      |&nbsp; Email:&nbsp; <a>riboseyim@gmail.com</a>
      |&nbsp; <a href="https://twitter.com/riboseyim" target="_blank" style="color:#939393;">Twitter</a>
      |&nbsp; <a href="https://github.com/riboseyim" target="_blank" style="color:#939393;">GitHub</a>
      |&nbsp; <a href="https://github.com/riboseyim/riboseyim.com.comment/issues" target="_blank"> 留言箱 Message Box</a>
    </div>
  </div>
  <div class="outer">
    <div  style="width:100%;margin:0 auto; padding:10px 0;text-align:center">
        主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank" style="color:#939393;font-size:80%">Hexo Cafe</a> |
       <a target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0" style="display:inline-block;text-decoration:none;color:#939393;font-size:80%">保持署名-非商业性使用-禁止演绎| License BY-NC-ND 4.0 </a> |
       <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1258500076'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1258500076%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
  </div>
  </div>
</footer>

<script src="/jquery/jquery.min.js"></script>


    </div>
    <nav id="mobile-nav">
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/tags/DevOps" class="mobile-nav-link">DevOps</a>
  
    <a href="/tags/Machine-Learning" class="mobile-nav-link">机器学习</a>
  
    <a href="/tags/Economist" class="mobile-nav-link">经济学人</a>
  
    <a href="/tags/Policy-Law" class="mobile-nav-link">Policy&amp;Law</a>
  
    <a href="/charts" class="mobile-nav-link">图表</a>
  
    <a href="/2017/02/09/eBook" class="mobile-nav-link">电子书</a>
  
    <a href="/2016/05/31/AboutMe" class="mobile-nav-link">关于</a>
  
    <a href="https://riboseyim.com" class="mobile-nav-link">TechBlog</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
    
 


  
  





  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>